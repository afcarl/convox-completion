#!/bin/bash
#
# bash completion file for core convox commands
#
# This script provides completion of:
# - commands and their options
# - racks and apps
# - filepaths

# To enable the completions either:
#  - place this file in /etc/bash_completion.d
#  or
#  - copy this file to e.g. ~/.convox-completion.sh and add the line
#    below to your .bashrc after bash completion features are loaded
#    . ~/.convox-completion.sh

# TODO: login --password $ENVVAR
# Note: The -f option to complete specifies filenames, and -X the filter pattern.
# http://tldp.org/LDP/abs/html/tabexpansion.html
# https://brbsix.github.io/2015/11/29/accessing-tab-completion-programmatically-in-bash/

export BASH_COMPLETION_DEBUG=true

: ${PROG:=$(basename ${BASH_SOURCE})}

_cli_bash_autocomplete() {
     local cur opts base
     COMPREPLY=()
     cur="${COMP_WORDS[COMP_CWORD]}"
     opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )
     COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
     return 0
 }

complete -F _cli_bash_autocomplete $PROG

#complete -F _cli_bash_autocomplete cx

## end original ##

###############
### HELPERS ###
###############

# Appends the word passed as an argument to every word in `$COMPREPLY`.
# Normally you do this with `compgen -S`. This function exists so that you can use
# the __convox_complete_XXX functions in cases where you need a suffix.
__convox_append_to_completions() {
        COMPREPLY=( ${COMPREPLY[@]/%/"$1"} )
}

# Finds the position of the first word that is neither option nor an option's argument.
# If there are options that require arguments, you should pass a glob describing those
# options, e.g. "--option1|-o|--option2"
# Use this function to restrict completions to exact positions after the argument list.
__convox_pos_first_nonflag() {
        local argument_flags=$1

        local counter=$((${subcommand_pos:-${command_pos}} + 1))
        while [ $counter -le $cword ]; do
                if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
                        (( counter++ ))
                        # eat "=" in case of --option=arg syntax
                        [ "${words[$counter]}" = "=" ] && (( counter++ ))
                else
                        case "${words[$counter]}" in
                                -*)
                                        ;;
                                *)
                                        break
                                        ;;
                        esac
                fi

                # Bash splits words at "=", retaining "=" as a word, examples:
                # "--debug=false" => 3 words, "--log-opt syslog-facility=daemon" => 4 words
                while [ "${words[$counter + 1]}" = "=" ] ; do
                        counter=$(( counter + 2))
                done

                (( counter++ ))
        done

        echo $counter
}

# If we are currently completing the value of a map option (key=value)
# which matches the extglob given as an argument, returns key.
# This function is needed for key-specific completions.
__convox_map_key_of_current_option() {
        local glob="$1"

        local key glob_pos
        if [ "$cur" = "=" ] ; then        # key= case
                key="$prev"
                glob_pos=$((cword - 2))
        elif [[ $cur == *=* ]] ; then     # key=value case (OSX)
                key=${cur%=*}
                glob_pos=$((cword - 1))
        elif [ "$prev" = "=" ] ; then
                key=${words[$cword - 2]}  # key=value case
                glob_pos=$((cword - 3))
        else
                return
        fi

        [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--))  # --option=key=value syntax

        [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}

# Returns the value of the first option matching option_glob.
# Valid values for option_glob are option names like '--log-level' and
# globs like '--log-level|-l'
# Only positions between the command and the current word are considered.
__convox_value_of_option() {
        local option_extglob=$(__convox_to_extglob "$1")

        local counter=$((command_pos + 1))
        while [ $counter -lt $cword ]; do
                case ${words[$counter]} in
                        $option_extglob )
                                echo ${words[$counter + 1]}
                                break
                                ;;
                esac
                (( counter++ ))
        done
}

# suppress trailing whitespace
__convox_nospace() {
    # compopt is not available in ancient bash versions
    type compopt &>/dev/null && compopt -o nospace
}

__convox_previous_extglob_setting=$(shopt -p extglob)
shopt -s extglob

__convox_q(){
    convox 2>/dev/null "$@"
}

__convox_complete_apps_all() {
    local IFS=$'\n'
    local apps=( $(__convox_q apps | grep -v APP | awk '{ print $1 }') )
    if [ "$1" ]; then
        apps=( $(__convox_q apps | grep "^$1" | grep -v APP | awk '{ print $1 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${apps[*]}" -- "$cur") )
}

__convox_complete_apps_by_rack() {
    # TODO
    __convox_complete_apps_all
}

__convox_complete_email() {
    if [ -f "$HOME/.convox/id" ]; then
        COMPREPLY=( $(compgen -W "$(cat $HOME/.convox/id)" -- "$cur") )
    fi
}

# FIXME: this returns releases, not available rack versions
__convox_complete_rack_versions() {
    local IFS=$'\n'
    local versions=( $(__convox_q rack releases | grep -v VERSION | awk '{ print $1 }') )
    if [ "$1" ]; then
        versions=( $(__convox_q rack releases | grep "^$1" | grep -v VERSION | awk '{ print $1 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${versions[*]}" -- "$cur") )
}

__convox_complete_racks_all() {
    local IFS=$'\n'
    local racks=( $(__convox_q racks | grep -v RACK | awk '{ print $1 }') )
    if [ "$1" ]; then
        racks=( $(__convox_q racks | grep "^$1" | grep -v RACK | awk '{ print $1 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${racks[*]}" -- "$cur") )
}

__convox_stacks() {
    __convox_q racks | grep -v RACK | awk '{ print $1 }' | tr '/' " " | awk '{ print $2 }'
}

__convox_complete_stacks_all() {
    local IFS=$'\n'
    local stacks=( $(__convox_q racks | grep -v RACK | awk '{ print $1 }' | tr '/' " " | awk '{ print $2 }') )
    if [ "$1" ]; then
        stacks=( $(__convox_q racks | grep "^$1" | grep -v RACK | awk '{ print $1 }' | tr '/' " " | awk '{ print $2 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${stacks[*]}" -- "$cur") )
}

__convox_complete_rack_params_no() {
    local IFS=$'\n'
    #local rack_params=( $(__convox_q rack_params | grep -v RACK | awk '{ print $1 }') )
    local rack_params=( $(__convox_rack_params) )
    if [ "$1" ]; then
        rack_params=( $(__convox_q rack_params | grep "^$1" | grep -v RACK | awk '{ print $1 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${rack_params[*]}" -- "$cur") )
}

__convox_complete_env_vars() {
    COMPREPLY=( $( _env_vars -- "\$$cur" ) )
}

_env_vars() {
    # FIXME: env var completions should include $ but maybe we should assume it
    # -P = prefix
    # -o bashdefault = fall back to default bash completions, which includes $envvars
    compgen -o bashdefault -P "$" -e -- "$cur"
}

_filedir() {
    COMPREPLY=( $( compgen $1 -- "$cur" ) )
}

__convox_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}

__convox_to_extglob () 
{ 
    local extglob=$( __convox_to_alternatives "$1" );
    echo "@($extglob)"
}

###################
### SUBCOMMANDS ###
###################

# Subcommand processing.
# Locates the first occurrence of any of the subcommands contained in the
# first argument. In case of a match, calls the corresponding completion
# function and returns 0.
# If no match is found, 1 is returned. The calling function can then
# continue processing its completion.
#
# TODO if the preceding command has options that accept arguments and an
# argument is equal ot one of the subcommands, this is falsely detected as
# a match.
# TODO this doesn't handle "sub-sub-commands" (e.g. convox resources create mysql)
__convox_subcommands() {
    local subcommands="$1"

    local counter=$(($command_pos + 1))
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in
            $(__convox_to_extglob "$subcommands") )
                subcommand_pos=$counter
                local subcommand=${words[$counter]}

                # This doesn't work :(
                # if there's a sub-sub-command, run it
                # local subsubcommand=${words[$counter-1]}
                # local subcompletions_func=_convox_${command}_${subsubcommand}
                # declare -F $subcompletions_func >/dev/null && $subcompletions_func && return 0

                # otherwise proceed as usual
                local completions_func=_convox_${command}_${subcommand}
                declare -F $completions_func >/dev/null && $completions_func
                return 0
                ;;   
        esac 
        (( counter++ ))
    done 
    return 1
}

##################
### WORD LISTS ###
##################

__convox_api_endpoints() {
    endpoints="
        /apps
        /auth
        /certificates
        /index
        /instances
        /racks
        /registries
        /resources
        /switch
        /system
    "
    compgen -W "$endpoints"
}

__convox_resource_types() {
    resource_types="
        fluentd
        memcached
        mysql
        postgres
        redis
        s3
        sns
        sqs
        syslog
        webhook
    "
    compgen -W "$resource_types"
}

# https://aws.amazon.com/ec2/instance-types/
__convox_instance_types() {
    instance_types="
        t2.nano
        t2.micro
        t2.small
        t2.medium
        t2.large
        t2.xlarge
        t2.2xlarge
        m4.large
        m4.xlarge
        m4.2xlarge
        m4.4xlarge
        m4.10xlarge
        m4.16xlarge
        m3.medium
        m3.large
        m3.xlarge
        m3.2xlarge
        c4.large
        c4.xlarge
        c4.2xlarge
        c4.4xlarge
        c4.8xlarge
        c3.large
        c3.xlarge
        c3.2xlarge
        c3.4xlarge
        c3.8xlarge
        x1.32.xlarge
        x1.16.xlarge
        r4.large
        r4.xlarge
        r4.2xlarge
        r4.4xlarge
        r4.8xlarge
        r4.16xlarge
        r3.large
        r3.xlarge
        r3.2xlarge
        r3.4xlarge
        r3.8xlarge
        p2
        g2
        f1
        i3
        d2
    "
    compgen -W "$instance_types"
}

__convox_build_instance_types() {
    # TODO: add remaining valid build instance types
    instance_types="
        m4.large
        m4.xlarge
        c4.large
    "
    compgen -W "$instance_types"
}

__convox_app_params() {
    app_params="
        Cluster
        CustomTopicRuntime
        DeploymentMaximum
        DeploymentMinimum
        Environment
        Internal
        Key
        Private
        Release
        Repository
        SecurityGroup
        Subnets
        SubnetsPrivate
        VPC
        VPCCIDR
        Version
        <service>Formation
        <service>Port<port>Certificate
        <service>Port<port>Host
    "
    #compgen -W "$app_params"
    compgen -S "=" -o nospace -W "$app_params"
}

__convox_rack_params() {
    rack_params="
        Ami
        ApiCpu
        ApiMemory
        Autoscale
        BuildCpu
        BuildImage
        BuildInstance
        BuildMemory
        ClientId
        ContainerDisk
        CustomTopicRuntime
        Development
        Encryption
        ExistingVpc
        InstanceBootCommand
        InstanceCount
        InstanceRunCommand
        InstanceType
        InstanceUpdateBatchSize
        Internal
        InternetGateway
        Key
        Password
        Private
        PrivateApi
        Subnet0CIDR
        Subnet1CIDR
        Subnet2CIDR
        SubnetPrivate0CIDR
        SubnetPrivate1CIDR
        SubnetPrivate2CIDR
        SwapSize
        Tenancy
        VPCCIDR
        Version
        VolumeSize
    "
    # TODO: nospace => shouldn't add a space to the end
    compgen -S "=" -o nospace -W "$rack_params"
}

__convox_regions() {
    regions="
        ap-northeast-1
        ap-southeast-1
        ap-southeast-2
        eu-central-1
        eu-west-1
        eu-west-2
        us-east-1
        us-east-2
        us-west-1
        us-west-2
    "
    compgen -W "$regions"
}

__convox_complete_get_api_endpoints() {
    COMPREPLY=( $( __convox_api_endpoints -- "$cur" ) )
}

__convox_complete_delete_api_endpoints() {
    COMPREPLY=( $( __convox_api_endpoints -- "$cur" ) )
}

__convox_complete_resource_types() {
    COMPREPLY=( $( compgen -W "$(__convox_resource_types)" -- "$cur" ) )
}

__convox_complete_instance_types() {
    COMPREPLY=( $( compgen -W "$(__convox_instance_types)" -- "$cur" ) )
}

__convox_complete_regions() {
    COMPREPLY=( $( compgen -W "$(__convox_regions)" -- "$cur" ) )
}

__convox_complete_app_params() {
    #COMPREPLY=( $( compgen -S "=" -W "$(__convox_app_params)" -- "$cur" ) )
    COMPREPLY=( $( "$(__convox_app_params)" -- "$cur" ) )
}

__convox_complete_rack_params() {
    COMPREPLY=( $( "$(__convox_rack_params)" -- "$cur" ) )
}

################
### COMMANDS ###
################

_convox() {
    local previous_extglob_setting=$(shopt -p extglob)
    shopt -s extglob

    local commands=$(convox --generate-bash-completion)

    # These options are valid as global options for all client commands
    local global_boolean_options="
            --version -v
            --help -h
            --generate-bash-completion
    "
    local global_options_with_args="
            --rack
            --app -a
    "

    local host config

    COMPREPLY=()
    local cur prev words cword
    _get_comp_words_by_ref -n : cur prev words cword

    local command='convox' command_pos=0 subcommand_pos
    local counter=1
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in
            # save app so that completion can use custom daemon
            --app|-a)
                (( counter++ ))
                app="${words[$counter]}"
                ;;
            --rack)
                (( counter++ ))
                rack="${words[$counter]}"
                ;;
            $(__convox_to_extglob "$global_options_with_args") )
                (( counter++ ))
                ;;
            -*)
                ;;
            =)
                (( counter++ ))
                ;;
            *)
                command="${words[$counter]}"
                command_pos=$counter
                break
                ;;
        esac
        (( counter++ ))
    done

    local binary="${words[0]}"
    local completions_func=_convox_${command}
    declare -F $completions_func >/dev/null && $completions_func

    eval "$previous_extglob_setting"
    return 0
}

_convox_convox() {
    local boolean_options="
        $global_boolean_options
        --help -h
        --version -v
    "

    case "$prev" in
        --config)
            _filedir -d
            return
            ;;
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
        #--log-level|-l)
            #__convox_complete_log_levels
            #return
            #;;
        $(__convox_to_extglob "$global_options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag "$(__convox_to_extglob "$global_options_with_args")" )
            if [ $cword -eq $counter ]; then
                COMPREPLY=( $( compgen -W "${commands[*]} help" -- "$cur" ) )
            fi
            ;;
    esac
}

_convox_api() {
    local subcommands=$(convox api --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_api_get() {
    local options_with_args="
        --rack
        --help -h
    "
    local boolean_options="
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_get_api_endpoints
            fi
            ;;
    esac
}

_convox_api_delete() {
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_delete_api_endpoints
            fi
            ;;
    esac
}

_convox_apps() {
    local subcommands=$(convox apps --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    local options_with_args="
        --rack
        --help -h
    "
    local boolean_options="
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            #COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_apps_cancel() {
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --app|-a)
            __convox_complete_apps_by_rack
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help --app -a --rack" -- "$cur" ) )
            ;;
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$global_options_with_args" -- "$cur" ) )
            return
            ;;
    esac
}

_convox_apps_delete() {
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--rack --help" -- "$cur" ) )
            ;;
        *)
            __convox_complete_apps_all
            ;;
    esac
}

_convox_apps_info() {
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            __convox_complete_apps_all
            ;;
    esac
}

_convox_apps_params() {
    local subcommands=$(convox apps params --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--app --help" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$subcommands") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_apps_set() {
    # FIXME: this is needed because of how __convox_subcommands infers the function name
    _convox_apps_params_set
}

_convox_apps_params_set() {
    local subcommands="$(__convox_app_params)"
    __convox_subcommands "$subcommands" && return

    local options_with_args="
    "

    local boolean_options="
        --help
        --rack
        --app -a
        --help -h
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            #COMPREPLY=( $( compgen -S "=" -W "$subcommands" -- "$cur" ) )
            #__convox_complete_app_params
            #__convox_append_to_completions "="
            #__convox_nospace
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        --rack)
            __convox_complete_racks_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            __convox_nospace
            ;;
    esac
}


_convox_build() {
    local options_with_args="
        --file
    "

    local boolean_options="
        --no-cache
        --build-arg
        --id
        --incremental
        --description
        --help
    "

    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        # environment variable / envvar example
        --build-arg)
            COMPREPLY=( $( compgen -e -- "$cur" ) )
            __convox_nospace
            return
            ;;
        --file|-f)
            _filedir
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            # FIXME: 'convox build' shouldn't take arguments
            # local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            # if [ $cword -eq $counter ]; then
                # _filedir -d
            # fi
            ;;
    esac

}

_convox_env() {
    local subcommands=$(convox env --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

# TODO: versions
_convox_install() {
    local options_with_args="
        --email
        --ami
        --build-instance
        --existing-vpc
        --instance-count
        --instance-type
        --internet-gateway
        --private-cidrs
        --region
        --stack-name
        --version
        --vpc-cidr
        --subnet-cidrs
    "

    local boolean_options="
        --help
        --dedicated
        --no-autoscale
        --private
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --name)
            return
            ;;
        --region)
            COMPREPLY=( $( __convox_regions -- "$cur" ) )
            return
            ;;
        --build-instance)
            COMPREPLY=( $( __convox_build_instance_types -- "$cur" ) )
            ;;
        --instance-type)
            COMPREPLY=( $( __convox_instance_types -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                _filedir -f
                return
            fi
            ;;
    esac
}


# TODO: convox instances
_convox_instances() {
    local subcommands=$(convox instances --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_rack() {
    local subcommands=$(convox rack --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_rack_logs() {
    #local subcommands=$(convox rack params --generate-bash-completion)
    #__convox_subcommands "$subcommands" && return
    local options_with_args="
        --rack
        --filter
        --since
    "
    local boolean_options="
        --follow
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        *)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        #*)
            #COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            #;;
        esac
}

_convox_rack_params() {
    local subcommands=$(convox rack params --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --rack
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$subcommands") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_rack_set() {
    # FIXME: this is needed because of how __convox_subcommands infers the function name
    _convox_rack_params_set
}
_convox_rack_params_set() {
    local subcommands="$(__convox_rack_params)"
    __convox_subcommands "$subcommands" && return

    local options_with_args="
    "

    local boolean_options="
        --rack
        --help
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            __convox_nospace
            ;;
    esac
}

_convox_rack_ps() {
    local subcommands=$(convox rack ps --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --rack
    "
    local boolean_options="
        --stats
        -a --all
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
        return
        ;;
    esac
}

# TODO: convox rack scale
_convox_rack_scale() {
    local options_with_args="
        --rack
        --count
        --type
    "
    local boolean_options="
        -h --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --type)
            __convox_complete_instance_types
            return
            ;;
        --count)
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
        return
        ;;
    esac
}

_convox_rack_update() {
    local options_with_args="
        --rack
    "
    local boolean_options="
        --wait
        -h --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --wait)
            __convox_complete_rack_versions
            #return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            __convox_complete_rack_versions
            return
            ;;
    esac
}

_convox_rack_releases() {
    local options_with_args="
        --rack
    "
    local boolean_options="
        --unpublished
        --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --unpublished)
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            return
            ;;
    esac
}

_convox_registries() {
    local subcommands=$(convox registries --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --rack
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            return
            ;;
    esac
}


_convox_registries_add() {
    local options_with_args="
        --rack
        --email -e
        --username -u
        --password -p
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --email)
            __convox_complete_email
            ;;
        --password)
            __convox_complete_env_vars
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            return
            ;;
    esac
}

# TODO: convox registries
# TODO: convox registries add
# TODO: convox registries remove

# TODO: convox releases

_convox_resources() {
    local subcommands=$(convox resources --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_resources_create() {
    #local subcommands=$(__convox_complete_resource_types)
    local subcommands="$(__convox_resource_types)"
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --name
    "

    local boolean_options="
        --help
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --name)
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        mysql)
            _convox_resources_create_mysql
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_resources_mysql() {
    # FIXME: this is needed because of how __convox_subcommands infers the function name
    _convox_resources_create_mysql
}

_convox_resources_create_mysql() {
    local boolean_options="
        --private
        --multi-az
    "
    local options_with_args="
        --allocated-storage
        --database
        --instance-type
        --password
        --username
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --allocated-storage|--database|--password|--username)
            #COMPREPLY=( $( "10" -- "$cur" ) )
            return
            ;;
        --instance-type)
            # FIXME: Tabbing after providing an instance types re-completes resource types
            __convox_complete_instance_types
            #__convox_complete_instance_types -- "$cur"
            #COMPREPLY=( $( __convox_complete_instance_types -- "$cur" ) )
            ;;
        mysql)
            # FIXME: we shouldn't need to handle this case
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            return
            ;;
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "raaa" -- "$cur" ) )
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options --foo" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_resource_types # FIXME: don't need to complete resources types if mysql already specified
            fi
            ;;
    esac

}

# TODO: convox run
# TODO: convox scale
# TODO: convox ssl
# TODO: convox start
# TODO: convox switch
# TODO: convox uninstall

_convox_uninstall() {
    local options_with_args="
    "

    local boolean_options="
        --help
        --force
    "

    local all_options="$options_with_args $boolean_options"
    #echo "$(__convox_stacks)"
    #echo $(__convox_stacks)
    #return
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        # FIXME: complete regions
        #$(__convox_to_extglob $(__convox_stacks)) )
            #COMPREPLY=( $( __convox_regions -- "$cur" ) )
            #COMPREPLY=( $( __convox_complete_regions -- "$cur" ) )
            #;;
        *)
            __convox_complete_stacks_all
            return
            ;;
    esac
    #echo "---"
    #echo "cur: $cur"
    #echo "prev: $prev"

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)

            #local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            #if [ $cword -eq $counter ]; then
                #__convox_complete_resource_types
            #fi
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_regions
                return
            else
                echo "$counter"
            fi
            ;;
    esac
}

# TODO: convox update



_convox_switch(){
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            __convox_complete_racks_all
            ;;
    esac
}


eval "$__convox_previous_extglob_setting"
unset __convox_previous_extglob_setting

complete -F _convox convox cx


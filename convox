#!/bin/bash
#
# bash completion file for core convox commands
#
# This script provides completion of:
# - commands and their options
# - racks and apps
# - filepaths

# To enable the completions either:
#  - place this file in /etc/bash_completion.d
#  or
#  - copy this file to e.g. ~/.convox-completion.sh and add the line
#    below to your .bashrc after bash completion features are loaded
#    . ~/.convox-completion.sh

# TODO: login --password $ENVVAR
# Note: The -f option to complete specifies filenames, and -X the filter pattern.
# http://tldp.org/LDP/abs/html/tabexpansion.html
# https://brbsix.github.io/2015/11/29/accessing-tab-completion-programmatically-in-bash/

export BASH_COMPLETION_DEBUG=true

: ${PROG:=$(basename ${BASH_SOURCE})}

_cli_bash_autocomplete() {
     local cur opts base
     COMPREPLY=()
     cur="${COMP_WORDS[COMP_CWORD]}"
     opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )
     COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
     return 0
 }

complete -F _cli_bash_autocomplete $PROG

###############
### HELPERS ###
###############

# Appends the word passed as an argument to every word in `$COMPREPLY`.
# Normally you do this with `compgen -S`. This function exists so that you can use
# the __convox_complete_XXX functions in cases where you need a suffix.
__convox_append_to_completions() {
        COMPREPLY=( ${COMPREPLY[@]/%/"$1"} )
}

stderr_echo() {
    >&2 echo "$@"
}

# Finds the position of the first word that is neither option nor an option's argument.
# If there are options that require arguments, you should pass a glob describing those
# options, e.g. "--option1|-o|--option2"
# Use this function to restrict completions to exact positions after the argument list.
__convox_pos_first_nonflag() {
        local argument_flags=$1

        local counter=$((${subcommand_pos:-${command_pos}} + 1))
        while [ $counter -le $cword ]; do
                if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
                        (( counter++ ))
                        # eat "=" in case of --option=arg syntax
                        [ "${words[$counter]}" = "=" ] && (( counter++ ))
                else
                        case "${words[$counter]}" in
                                -*)
                                        ;;
                                *)
                                        break
                                        ;;
                        esac
                fi

                # Bash splits words at "=", retaining "=" as a word, examples:
                # "--debug=false" => 3 words, "--log-opt syslog-facility=daemon" => 4 words
                while [ "${words[$counter + 1]}" = "=" ] ; do
                    counter=$(( counter + 2))
                done

                (( counter++ ))
        done

        echo $counter
}

# If we are currently completing the value of a map option (key=value)
# which matches the extglob given as an argument, returns key.
# This function is needed for key-specific completions.
__convox_map_key_of_current_option() {
        local glob="$1"

        local key glob_pos
        if [ "$cur" = "=" ] ; then        # key= case
                key="$prev"
                glob_pos=$((cword - 2))
        elif [[ $cur == *=* ]] ; then     # key=value case (OSX)
                key=${cur%=*}
                glob_pos=$((cword - 1))
        elif [ "$prev" = "=" ] ; then
                key=${words[$cword - 2]}  # key=value case
                glob_pos=$((cword - 3))
        else
                return
        fi

        [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--))  # --option=key=value syntax

        [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}

# Returns the value of the first option matching option_glob.
# Valid values for option_glob are option names like '--log-level' and
# globs like '--log-level|-l'
# Only positions between the command and the current word are considered.
__convox_value_of_option() {
        local option_extglob=$(__convox_to_extglob "$1")

        local counter=$((command_pos + 1))
        while [ $counter -lt $cword ]; do
                case ${words[$counter]} in
                        $option_extglob )
                                echo ${words[$counter + 1]}
                                break
                                ;;
                esac
                (( counter++ ))
        done
}

# suppress trailing whitespace
__convox_nospace() {
    # compopt is not available in ancient bash versions
    type compopt &>/dev/null && compopt -o nospace
}

__convox_previous_extglob_setting=$(shopt -p extglob)
shopt -s extglob

__convox_q(){
    convox 2>/dev/null "$@"
}

###########################
### DYNAMIC COMPLETIONS ###
###########################

__convox_complete_apps_all() {
    local IFS=$'\n'
    local apps=( $(__convox_q apps | grep -v APP | awk '{ print $1 }') )
    if [ "$1" ]; then
        apps=( $(__convox_q apps | grep "^$1" | grep -v APP | awk '{ print $1 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${apps[*]}" -- "$cur") )
}

__convox_complete_apps_by_rack() {
    # TODO
    __convox_complete_apps_all
}

__convox_complete_email() {
    if [ -f "$HOME/.convox/id" ]; then
        COMPREPLY=( $(compgen -W "$(cat $HOME/.convox/id)" -- "$cur") )
    fi
}

# FIXME: this returns releases, not available rack versions
__convox_complete_rack_versions() {
    local IFS=$'\n'
    local versions=( $(__convox_q rack releases | grep -v VERSION | awk '{ print $1 }') )
    if [ "$1" ]; then
        versions=( $(__convox_q rack releases | grep "^$1" | grep -v VERSION | awk '{ print $1 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${versions[*]}" -- "$cur") )
}

__convox_complete_racks_all() {
    COMPREPLY=( $(compgen -W "personal/dev" -- "$cur") )
    #local IFS=$'\n'
    #local racks=( $(__convox_racks $1) )
    #unset IFS
    #COMPREPLY=( $(compgen -W "${racks[*]}" -- "$cur") )
}

__convox_complete_stacks_all() {
    local IFS=$'\n'
    local stacks=( $(__convox_q racks | grep -v RACK | awk '{ print $1 }' | tr '/' " " | awk '{ print $2 }') )
    if [ "$1" ]; then
        stacks=( $(__convox_q racks | grep "^$1" | grep -v RACK | awk '{ print $1 }' | tr '/' " " | awk '{ print $2 }') )
    fi
    unset IFS
    COMPREPLY=( $(compgen -W "${stacks[*]}" -- "$cur") )
}

__convox_complete_yes_or_no() {
    COMPREPLY=( $( __convox_yes_or_no -- "$cur" ) )
}

__convox_complete_get_api_endpoints() {
    COMPREPLY=( $( compgen -W "$(__convox_api_endpoints)" -- "$cur" ) )
}

__convox_complete_delete_api_endpoints() {
    COMPREPLY=( $( compgen -W "$(__convox_api_endpoints)" -- "$cur" ) )
}

__convox_complete_resource_types() {
    COMPREPLY=( $( compgen -W "$(__convox_resource_types)" -- "$cur" ) )
}

__convox_complete_instance_types() {
    COMPREPLY=( $( compgen -W "$(__convox_instance_types)" -- "$cur" ) )
}

__convox_complete_regions() {
    COMPREPLY=( $( compgen -W "$(__convox_regions)" -- "$cur" ) )
}

__convox_complete_app_params() {
    #COMPREPLY=( $( compgen -S "=" -W "$(__convox_app_params)" -- "$cur" ) )
    COMPREPLY=( $( "$(__convox_app_params)" -- "$cur" ) )
}

__convox_complete_rack_params() {
    COMPREPLY=( $( "$(__convox_rack_params)" -- "$cur" ) )
}

__convox_complete_env_vars() {
    COMPREPLY=( $( _env_vars -- "\$$cur" ) )
}

_env_vars() {
    # FIXME: env var completions should include $ but maybe we should assume it
    # -P = prefix
    # -o bashdefault = fall back to default bash completions, which includes $envvars
    compgen -o bashdefault -P "$" -e -- "$cur"
}

_filedir() {
    COMPREPLY=( $( compgen $1 -- "$cur" ) )
}

__convox_to_alternatives () 
{ 
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}

__convox_to_extglob () 
{ 
    local extglob=$( __convox_to_alternatives "$1" );
    echo "@($extglob)"
}

###################
### SUBCOMMANDS ###
###################

# Subcommand processing.
# Locates the first occurrence of any of the subcommands contained in the
# first argument. In case of a match, calls the corresponding completion
# function and returns 0.
# If no match is found, 1 is returned. The calling function can then
# continue processing its completion.
#
# TODO if the preceding command has options that accept arguments and an
# argument is equal ot one of the subcommands, this is falsely detected as
# a match.
# TODO this doesn't handle "sub-sub-commands" (e.g. convox resources create mysql)
__convox_subcommands() {
    local subcommands="$1"
    #local subcommands="$@"
    #stderr_echo "subcommands: $subcommands"

    local counter=$(($command_pos + 1))
    while [ $counter -lt $cword ]; do
        parent="${words[$counter - 1]}"
        #stderr_echo
        #stderr_echo "parent: $parent"
        #stderr_echo "command: $command"
        #if [ ! "$parent" = "$command" ] ; then
            #stderr_echo "$parent and $command are different"
        #else
            #stderr_echo "$parent and $command are the same"
        #fi

        case "${words[$counter]}" in
            $(__convox_to_extglob "$subcommands") )
                subcommand_pos=$counter
                local subcommand=${words[$counter]}

                local completions_func=_convox_${command}_${subcommand}
                declare -F $completions_func >/dev/null && $completions_func # && return 0 || stderr_echo "completions_func not found: $completions_func"

                # if there's a sub-sub-command, run it
                if [ ! "$parent" = "$command" ] ; then
                    local completions_func=_convox_${command}_${parent}_${subcommand}
                    #stderr_echo "Trying parent: $completions_func"
                    declare -F $completions_func >/dev/null && $completions_func # && return 0 || stderr_echo "completions_func not found: $completions_func"
                fi
                return 0
                ;;   
        esac 
        (( counter++ ))
    done 
    return 1
}

##########################
### DYNAMIC WORD LISTS ###
##########################

__convox_stacks() {
    __convox_q racks | grep -v RACK | awk '{ print $1 }' | tr '/' " " | awk '{ print $2 }'
}

__convox_racks() {
    if [ "$1" ]; then
        __convox_q racks | grep -v RACK | grep ^$1 | awk '{ print $1 }'
    else
        __convox_q racks | grep -v RACK | awk '{ print $1 }'
    fi
    #local racks=( $(__convox_q racks | grep -v RACK | awk '{ print $1 }') )
}

##################
### WORD LISTS ###
##################

__convox_api_endpoints() {
    endpoints="
        /apps
        /auth
        /certificates
        /index
        /instances
        /racks
        /registries
        /resources
        /switch
        /system
    "
    compgen -W "$endpoints"
}

__convox_resource_types() {
    resource_types="
        fluentd
        memcached
        mysql
        postgres
        redis
        s3
        sns
        sqs
        syslog
        webhook
    "
    compgen -W "$resource_types"
}

# https://aws.amazon.com/ec2/instance-types/
__convox_instance_types() {
    instance_types="
        t2.nano
        t2.micro
        t2.small
        t2.medium
        t2.large
        t2.xlarge
        t2.2xlarge
        m4.large
        m4.xlarge
        m4.2xlarge
        m4.4xlarge
        m4.10xlarge
        m4.16xlarge
        m3.medium
        m3.large
        m3.xlarge
        m3.2xlarge
        c4.large
        c4.xlarge
        c4.2xlarge
        c4.4xlarge
        c4.8xlarge
        c3.large
        c3.xlarge
        c3.2xlarge
        c3.4xlarge
        c3.8xlarge
        x1.32.xlarge
        x1.16.xlarge
        r4.large
        r4.xlarge
        r4.2xlarge
        r4.4xlarge
        r4.8xlarge
        r4.16xlarge
        r3.large
        r3.xlarge
        r3.2xlarge
        r3.4xlarge
        r3.8xlarge
        p2
        g2
        f1
        i3
        d2
    "
    compgen -W "$instance_types"
}

__convox_dedicated_instance_types() {
    dedicated_instance_types="
        m4.large
        m4.xlarge
        m4.2xlarge
        m4.4xlarge
        m4.10xlarge
        m4.16xlarge
        c4.large
        c4.xlarge
        c4.2xlarge
        c4.4xlarge
        c4.8xlarge
        x1.16xlarge
        x1.32xlarge
        r3.large
        r3.xlarge
        r3.2xlarge
        r3.4xlarge
        r3.8xlarge
        r4.large
        r4.xlarge
        r4.2xlarge
        r4.4xlarge
        r4.8xlarge
        r4.16xlarge
        i3.large
        i3.xlarge
        i3.2xlarge
        i3.4xlarge
        i3.8xlarge
        i3.16xlarge
        d2.xlarge
        d2.2xlarge
        d2.4xlarge
        d2.8xlarge
    "
    compgen -W "$dedicated_instance_types"
}

__convox_build_instance_types() {
    # TODO: add remaining valid build instance types
    build_instance_types="
        m4.large
        m4.xlarge
        c4.large
    "
    compgen -W "$build_instance_types"
}

__convox_app_params() {
    app_params="
        Cluster
        CustomTopicRuntime
        DeploymentMaximum
        DeploymentMinimum
        Environment
        Internal
        Key
        Private
        Release
        Repository
        SecurityGroup
        Subnets
        SubnetsPrivate
        VPC
        VPCCIDR
        Version
        <service>Formation
        <service>Port<port>Certificate
        <service>Port<port>Host
    "
    #compgen -W "$app_params"
    compgen -S "=" -o nospace -W "$app_params"
}

__convox_rack_params() {
    rack_params="
        Ami
        ApiCpu
        ApiMemory
        Autoscale
        BuildCpu
        BuildImage
        BuildInstance
        BuildMemory
        ClientId
        ContainerDisk
        CustomTopicRuntime
        Development
        Encryption
        ExistingVpc
        InstanceBootCommand
        InstanceCount
        InstanceRunCommand
        InstanceType
        InstanceUpdateBatchSize
        Internal
        InternetGateway
        Key
        Password
        Private
        PrivateApi
        Subnet0CIDR
        Subnet1CIDR
        Subnet2CIDR
        SubnetPrivate0CIDR
        SubnetPrivate1CIDR
        SubnetPrivate2CIDR
        SwapSize
        Tenancy
        VPCCIDR
        Version
        VolumeSize
    "
    compgen -S "=" -o nospace -W "$rack_params"
}

__convox_regions() {
    regions="
        ap-northeast-1
        ap-southeast-1
        ap-southeast-2
        eu-central-1
        eu-west-1
        eu-west-2
        us-east-1
        us-east-2
        us-west-1
        us-west-2
    "
    compgen -W "$regions"
}

__convox_yes_or_no() {
    yes_or_no="
        Yes
        No
    "
    compgen -W "$yes_or_no"
}

################
### COMMANDS ###
################

_convox() {
    local previous_extglob_setting=$(shopt -p extglob)
    shopt -s extglob

    local commands=$(convox --generate-bash-completion)

    # These options are valid as global options for all client commands
    local global_boolean_options="
            --version -v
            --help -h
            --generate-bash-completion
    "
    local global_options_with_args="
            --rack
            --app -a
    "

    local host config

    COMPREPLY=()
    local cur prev words cword
    _get_comp_words_by_ref -n : cur prev words cword

    local command='convox' command_pos=0 subcommand_pos
    local counter=1
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in
            # save app so that completion can use custom daemon
            --app|-a)
                (( counter++ ))
                app="${words[$counter]}"
                ;;
            --rack)
                (( counter++ ))
                rack="${words[$counter]}"
                ;;
            $(__convox_to_extglob "$global_options_with_args") )
                (( counter++ ))
                ;;
            -*)
                ;;
            =)
                (( counter++ ))
                ;;
            *)
                command="${words[$counter]}"
                command_pos=$counter
                break
                ;;
        esac
        (( counter++ ))
    done

    local binary="${words[0]}"
    local completions_func=_convox_${command}
    declare -F $completions_func >/dev/null && $completions_func

    eval "$previous_extglob_setting"
    return 0
}

_convox_convox() {
    local boolean_options="
        $global_boolean_options
        --help -h
        --version -v
    "

    case "$prev" in
        --config)
            _filedir -d
            return
            ;;
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
        #--log-level|-l)
            #__convox_complete_log_levels
            #return
            #;;
        $(__convox_to_extglob "$global_options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag "$(__convox_to_extglob "$global_options_with_args")" )
            if [ $cword -eq $counter ]; then
                COMPREPLY=( $( compgen -W "${commands[*]} help" -- "$cur" ) )
            fi
            ;;
    esac
}

_convox_api() {
    local subcommands=$(convox api --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_api_get() {
    local options_with_args="
        --rack
        --help -h
    "
    local boolean_options="
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_get_api_endpoints
            fi
            ;;
    esac
}

_convox_api_delete() {
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_delete_api_endpoints
            fi
            ;;
    esac
}

_convox_apps() {
    local subcommands=$(convox apps --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    local options_with_args="
        --rack
        --help -h
    "
    local boolean_options="
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            #COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_apps_cancel() {
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --app|-a)
            __convox_complete_apps_by_rack
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help --app -a --rack" -- "$cur" ) )
            ;;
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$global_options_with_args" -- "$cur" ) )
            return
            ;;
    esac
}

_convox_apps_delete() {
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--rack --help" -- "$cur" ) )
            ;;
        *)
            __convox_complete_apps_all
            ;;
    esac
}

_convox_apps_info() {
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            __convox_complete_apps_all
            ;;
    esac
}

_convox_apps_params() {
    local subcommands=$(convox apps params --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--app --help" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$subcommands") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_apps_set() {
    # FIXME: this is needed because of how __convox_subcommands infers the function name
    _convox_apps_params_set
}

_convox_apps_params_set() {
    local subcommands="$(__convox_app_params)"
    __convox_subcommands "$subcommands" && return

    local options_with_args="
    "

    local boolean_options="
        --help
        --rack
        --app -a
        --help -h
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            #COMPREPLY=( $( compgen -S "=" -W "$subcommands" -- "$cur" ) )
            #__convox_complete_app_params
            #__convox_append_to_completions "="
            #__convox_nospace
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        --rack)
            __convox_complete_racks_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            __convox_nospace
            ;;
    esac
}


_convox_build() {
    local options_with_args="
        --file
    "

    local boolean_options="
        --no-cache
        --build-arg
        --id
        --incremental
        --description
        --help
    "

    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        # environment variable / envvar example
        --build-arg)
            COMPREPLY=( $( compgen -e -- "$cur" ) )
            __convox_nospace
            return
            ;;
        --file|-f)
            _filedir
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            # FIXME: 'convox build' shouldn't take arguments
            # local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            # if [ $cword -eq $counter ]; then
                # _filedir -d
            # fi
            ;;
    esac

}

_convox_builds() {
    local subcommands=$(convox builds --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --app
        --rack
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--app --help" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$subcommands") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_builds_create() {
    local options_with_args="
        --app
        --rack
        --file -f
        --description
    "
    local boolean_options="
        --no-cache
        --id
        --incremental
        --help
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                # FIXME: this should only complete directories, not files
                _filedir -d
                return
            fi
            ;;
    esac
}

# TODO: convox builds create
# TODO: convox builds delete
# TODO: convox builds export
# TODO: convox builds import
# TODO: convox builds info
# TODO: convox builds logs

_convox_env() {
    local subcommands=$(convox env --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

# TODO: versions
_convox_install() {
    local options_with_args="
        --email
        --ami
        --build-instance
        --existing-vpc
        --instance-count
        --instance-type
        --internet-gateway
        --private-cidrs
        --region
        --stack-name
        --version
        --vpc-cidr
        --subnet-cidrs
    "

    local boolean_options="
        --help
        --dedicated
        --no-autoscale
        --private
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --name)
            return
            ;;
        --region)
            __convox_complete_regions
            #COMPREPLY=( $( __convox_regions -- "$cur" ) )
            return
            ;;
        --build-instance)
            # TODO
            COMPREPLY=( $( __convox_build_instance_types -- "$cur" ) )
            ;;
        --instance-type)
            __convox_complete_instance_types
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                _filedir -f
                return
            fi
            ;;
    esac
}


_convox_instances() {
    local subcommands=$(convox instances --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_rack() {
    local subcommands=$(convox rack --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    local options_with_args="
        --rack
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_rack_logs() {
    local options_with_args="
        --rack
        --filter
        --since
    "
    local boolean_options="
        --follow
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        *)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        #*)
            #COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            #;;
        esac
}

_convox_rack_params() {
    local subcommands=$(convox rack params --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --rack
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$subcommands") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

_convox_rack_set() {
    # FIXME: this is needed because of how __convox_subcommands infers the function name
    _convox_rack_params_set
}

_convox_rack_params_set() {
    local subcommands="$(__convox_rack_params)"
    __convox_subcommands "$subcommands" && return

    local options_with_args="
    "

    local boolean_options="
        --rack
        --help
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        Private|Internal)
            __convox_complete_yes_or_no
            return
            ;;
        #InstanceType*)
            #__convox_complete_instance_types
            #return
            #;;
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac

    case "$cur" in
        #InstanceType*)
            #__convox_complete_instance_types
            #return
            #;;
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            __convox_nospace
            ;;
    esac
}

_convox_rack_ps() {
    local subcommands=$(convox rack ps --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --rack
    "
    local boolean_options="
        --stats
        -a --all
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack|-r)
            __convox_complete_racks_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
        return
        ;;
    esac
}

# TODO: convox rack scale
_convox_rack_scale() {
    local options_with_args="
        --rack
        --count
        --type
    "
    local boolean_options="
        -h --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --type)
            __convox_complete_instance_types
            return
            ;;
        --count)
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
        return
        ;;
    esac
}

_convox_rack_update() {
    local options_with_args="
        --rack
    "
    local boolean_options="
        --wait
        -h --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --wait)
            __convox_complete_rack_versions
            #return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            __convox_complete_rack_versions
            return
            ;;
    esac
}

_convox_rack_releases() {
    local options_with_args="
        --rack
    "
    local boolean_options="
        --unpublished
        --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --unpublished)
            return
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
        *)
            return
            ;;
    esac
}

_convox_registries() {
    local subcommands=$(convox registries --generate-bash-completion)
    __convox_subcommands "$subcommands" && return

    local options_with_args="
        --rack
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"

    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            return
            ;;
    esac
}


_convox_registries_add() {
    local options_with_args="
        --rack
        --email -e
        --username -u
        --password -p
    "
    local boolean_options="
        --help
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --email)
            __convox_complete_email
            ;;
        --password)
            __convox_complete_env_vars
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)
            return
            ;;
    esac
}

# TODO: convox registries
# TODO: convox registries add
# TODO: convox registries remove

# TODO: convox releases

_convox_resources() {
    local subcommands=$(convox resources --generate-bash-completion)
    __convox_subcommands "$subcommands" && return
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            COMPREPLY=( $( compgen -W "$subcommands" -- "$cur" ) )
            ;;
    esac
}

__docker_complete_log_options() {
        # see docs/reference/logging/index.md
        local awslogs_options="awslogs-region awslogs-group awslogs-stream"
        local fluentd_options="env fluentd-address fluentd-async-connect fluentd-buffer-limit fluentd-retry-wait fluentd-max-retries labels tag"
        local gcplogs_options="env gcp-log-cmd gcp-project labels"
        local gelf_options="env gelf-address gelf-compression-level gelf-compression-type labels tag"
        local journald_options="env labels tag"
        local json_file_options="env labels max-file max-size"
        local syslog_options="env labels syslog-address syslog-facility syslog-format syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify tag"
        local splunk_options="env labels splunk-caname splunk-capath splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url tag"

        local all_options="$fluentd_options $gcplogs_options $gelf_options $journald_options $json_file_options $syslog_options $splunk_options"

        case $(__docker_value_of_option --log-driver) in
                '')
                        COMPREPLY=( $( compgen -W "$all_options" -S = -- "$cur" ) )
                        ;;
                awslogs)
                        COMPREPLY=( $( compgen -W "$awslogs_options" -S = -- "$cur" ) )
                        ;;
                fluentd)
                        COMPREPLY=( $( compgen -W "$fluentd_options" -S = -- "$cur" ) )
                        ;;
                gcplogs)
                        COMPREPLY=( $( compgen -W "$gcplogs_options" -S = -- "$cur" ) )
                        ;;
                gelf)
                        COMPREPLY=( $( compgen -W "$gelf_options" -S = -- "$cur" ) )
                        ;;
                journald)
                        COMPREPLY=( $( compgen -W "$journald_options" -S = -- "$cur" ) )
                        ;;
                json-file)
                        COMPREPLY=( $( compgen -W "$json_file_options" -S = -- "$cur" ) )
                        ;;
                syslog)
                        COMPREPLY=( $( compgen -W "$syslog_options" -S = -- "$cur" ) )
                        ;;
                splunk)
                        COMPREPLY=( $( compgen -W "$splunk_options" -S = -- "$cur" ) )
                        ;;
                *)
                        return
                        ;;
        esac

        __docker_nospace
}


_convox_resources_create() {
    resources_create_options_with_args="
        --name
    "
    resources_create_boolean_options="
        --help
    "
    local all_options="$resources_create_options_with_args $resources_create_boolean_options"

    case "$prev" in
        # if previous word is a flag preceding an argument, don't start completing more flags yet
        $(__convox_to_extglob "$resources_create_options_with_args") )
            return
            ;;
        --instance-type)
            __convox_complete_instance_types
            return
            ;;
        $(__convox_to_extglob "$all_options") )
            _convox_resources_create_${prev}
            return
            ;;
        $(__convox_to_extglob "$(__convox_resource_types)") )
            RESOURCE_TYPE=$prev
            _convox_resources_create_${prev}
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            echo "prev is an option with arg"
            return
            ;;
        *)
            return
            ;;
    esac

    # in case user has backspaced over the resource type we were tracking
    [ "$prev" = "create" ] && unset RESOURCE_TYPE

    case $RESOURCE_TYPE in
        $(__convox_to_extglob "$(__convox_resource_types)") )
            _convox_resources_create_${RESOURCE_TYPE}
            return
        ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$(__convox_resource_types)") )
            RESOURCE_TYPE=$prev
            #echo "RESOURCE TYPE: $RESOURCE_TYPE" >> /tmp/resourcetype
            _convox_resources_create_${prev}
            return
            ;;
        *)
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_resource_types
                return
            fi
            return
            ;;
    esac
}

_convox_resources_create_fluentd() {
    local boolean_options="
        $resources_create_boolean_options
    "
    local options_with_args="
        $resources_create_options_with_args
        --url
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        #*)
            #local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            #if [ $cword -eq $counter ]; then
                #__convox_complete_resource_types
                #return
            #fi
            #return
            #;;
    esac
}

_convox_resources_create_mysql() {
    local boolean_options="
        $resources_create_boolean_options
        --private
        --multi-az
    "
    local options_with_args="
        $resources_create_options_with_args
        --allocated-storage
        --database
        --instance-type
        --password
        --username
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --instance-type)
            __convox_complete_instance_types
            ;;
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        #*)
            #local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            #if [ $cword -eq $counter ]; then
                #__convox_complete_resource_types
                #return
            #fi
            #;;
    esac
}

_convox_resources_create_postgres() {
    local boolean_options="
        $resources_create_boolean_options
        --multi-az
        --private
    "
    local options_with_args="
        $resources_create_options_with_args
        --database
        --instance-type
        --max-connections
        --password
        --username
        --version
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
    esac
}

_convox_resources_create_redis() {
    local boolean_options="
        --automatic-failover-enabled
        $resources_create_boolean_options
    "
    local options_with_args="
        $resources_create_options_with_args
        --database
        --instance-type
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
    esac
}

_convox_resources_create_s3() {
    local boolean_options="
        --versioning
        $resources_create_boolean_options
    "
    local options_with_args="
        $resources_create_options_with_args
        --topic
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
    esac
}

_convox_resources_create_sns() {
    local boolean_options="
        $resources_create_boolean_options
    "
    local options_with_args="
        $resources_create_options_with_args
        --queue
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
    esac
}

_convox_resources_create_sqs() {
    local boolean_options="
        $resources_create_boolean_options
    "
    local options_with_args="
        $resources_create_options_with_args
        --message-retention-period
        --receive-message-wait-time
        --visibility-timeout
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            echo "prev is an option with arg"
            return
            ;;
        *)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
}

_convox_resources_create_syslog() {
    local boolean_options="
        $resources_create_boolean_options
        --private
    "
    local options_with_args="
        $resources_create_options_with_args
        --url
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac
}

_convox_run() {
    local options_with_args="
        --app -a
        --rack
        --release -r
    "
    local boolean_options="
        --detach
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --rack)
            __convox_complete_racks_all
            return
            ;;
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        --release|-r)
            # TODO: __convox_complete_releases_by_app ?
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
    esac
}

_convox_scale() {
    local options_with_args="
        --app -a
        --count
        --cpu
        --memory
        --rack
    "
    local boolean_options="
        --wait
    "
    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        --app|-a)
            __convox_complete_apps_all
            return
            ;;
        --cpu|--count|--memory)
            return
            ;;
        --rack)
            __convox_complete_racks_all
            return
            ;;
        $(__convox_to_extglob "$options_with_args") )
            return
            ;;
    esac

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
    esac
}

# TODO: convox ssl
# TODO: convox start
# TODO: convox switch

_convox_uninstall() {
    local options_with_args="
    "

    local boolean_options="
        --help
        --force
    "

    local all_options="$options_with_args $boolean_options"
    case "$prev" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        # FIXME: complete regions
        #$(__convox_to_extglob $(__convox_stacks)) )
            #COMPREPLY=( $( __convox_regions -- "$cur" ) )
            #COMPREPLY=( $( __convox_complete_regions -- "$cur" ) )
            #;;
        *)
            __convox_complete_stacks_all
            return
            ;;
    esac
    #echo "---"
    #echo "cur: $cur"
    #echo "prev: $prev"

    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "$all_options" -- "$cur" ) )
            ;;
        *)

            #local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            #if [ $cword -eq $counter ]; then
                #__convox_complete_resource_types
            #fi
            local counter=$( __convox_pos_first_nonflag $( __convox_to_alternatives "$options_with_args" ) )
            if [ $cword -eq $counter ]; then
                __convox_complete_regions
                return
            fi
            ;;
    esac
}

# TODO: convox update



_convox_switch(){
    case "$cur" in
        -*)
            COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
            ;;
        *)
            __convox_complete_racks_all
            ;;
    esac
}


eval "$__convox_previous_extglob_setting"
unset __convox_previous_extglob_setting

complete -F _convox convox cx

